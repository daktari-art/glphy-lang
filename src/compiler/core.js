// Glyph Language Core Compiler
class GlyphCompiler {
    constructor() {
        this.nodeTypes = {
            'DATA_NODE': 'â—‹',
            'TEXT_NODE': 'â–¡', 
            'LIST_NODE': 'â–³',
            'BOOL_NODE': 'â—‡',
            'FUNCTION_NODE': 'â–·',
            'LOOP_NODE': 'âŸ³',
            'CONDITION_NODE': 'â—¯',
            'OUTPUT_NODE': 'â¤¶',
            'ERROR_NODE': 'âš¡',
            'ASYNC_NODE': 'ðŸ”„'
        };
    }

    // Parse Glyph program into AST
    parse(glyphCode) {
        const ast = {
            type: 'Program',
            body: [],
            connections: []
        };

        const lines = glyphCode.split('\n');
        
        lines.forEach(line => {
            const nodeMatch = line.match(/\[([â—‹â–¡â–³â—‡â–·âŸ³â—¯â¤¶âš¡ðŸ”„])\s+([^\]]+)\]/);
            if (nodeMatch) {
                ast.body.push({
                    type: this.getNodeType(nodeMatch[1]),
                    value: nodeMatch[2].trim(),
                    glyph: nodeMatch[1]
                });
            }

            const connectionMatch = line.match(/(â†’|âš¡|ðŸ”„|â¤´|â¤µ)/);
            if (connectionMatch) {
                ast.connections.push({
                    type: this.getConnectionType(connectionMatch[1]),
                    glyph: connectionMatch[1]
                });
            }
        });

        return ast;
    }

    getNodeType(glyph) {
        const types = {
            'â—‹': 'DATA_NODE',
            'â–¡': 'TEXT_NODE',
            'â–³': 'LIST_NODE', 
            'â—‡': 'BOOL_NODE',
            'â–·': 'FUNCTION_NODE',
            'âŸ³': 'LOOP_NODE',
            'â—¯': 'CONDITION_NODE',
            'â¤¶': 'OUTPUT_NODE',
            'âš¡': 'ERROR_NODE',
            'ðŸ”„': 'ASYNC_NODE'
        };
        return types[glyph] || 'UNKNOWN_NODE';
    }

    getConnectionType(glyph) {
        const types = {
            'â†’': 'DATA_FLOW',
            'âš¡': 'ERROR_FLOW',
            'ðŸ”„': 'ASYNC_FLOW', 
            'â¤´': 'RETURN_FLOW',
            'â¤µ': 'INPUT_FLOW'
        };
        return types[glyph] || 'UNKNOWN_FLOW';
    }

    // Compile to JavaScript
    compileToJS(ast) {
        let jsCode = '// Generated by Glyph Compiler\n';
        jsCode += 'const glyphRuntime = {\n';
        
        ast.body.forEach((node, index) => {
            jsCode += `  node${index}: ${this.generateNodeJS(node)},\n`;
        });

        jsCode += '};\n';
        jsCode += 'export default glyphRuntime;';
        
        return jsCode;
    }

    generateNodeJS(node) {
        switch(node.type) {
            case 'DATA_NODE':
                return `() => ${this.parseValue(node.value)}`;
            case 'TEXT_NODE':
                return `() => "${node.value}"`;
            case 'OUTPUT_NODE':
                return `(value) => console.log(value)`;
            default:
                return `() => ${node.value}`;
        }
    }

    parseValue(value) {
        // Try to parse as number, boolean, or keep as string
        if (!isNaN(value)) return Number(value);
        if (value === 'true' || value === 'false') return value === 'true';
        if (value.startsWith('"') && value.endsWith('"')) 
            return value.slice(1, -1);
        return `"${value}"`;
    }
}

module.exports = GlyphCompiler;
