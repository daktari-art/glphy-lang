<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîÆ Glyph Language - WORKING Multi-Input Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: #2c3e50; color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .demo-area { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 30px; }
        .code-editor, .output-display { width: 100%; height: 300px; padding: 20px; border-radius: 10px; font-family: 'Fira Code', monospace; font-size: 14px; }
        .code-editor { border: 2px solid #e0e0e0; background: #f8f9fa; resize: vertical; }
        .output-display { border: 2px solid #e0e0e0; background: #1e1e1e; color: #00ff00; overflow-y: auto; }
        .controls { display: flex; gap: 15px; margin-top: 20px; }
        .btn { padding: 12px 25px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; }
        .btn-run { background: #27ae60; color: white; }
        .btn-examples { background: #3498db; color: white; }
        .btn-clear { background: #e74c3c; color: white; }
        .success { color: #27ae60; }
        .error { color: #e74c3c; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÆ Glyph Language - WORKING Multi-Input Demo</h1>
            <div class="subtitle">Multi-Input Functions Now Work Correctly!</div>
        </div>
        
        <div class="demo-area">
            <div class="editor-section">
                <div class="section-title">üìù Write Glyph Code</div>
                <textarea class="code-editor" id="codeEditor">[‚óã 5] ‚Üí [‚ñ∑ multiply] ‚Üê [‚óã 6] ‚Üí [‚ñ∑ print]
[‚ñ° "hello"] ‚Üí [‚ñ∑ concat] ‚Üê [‚ñ° " world"] ‚Üí [‚ñ∑ print]</textarea>
                
                <div class="controls">
                    <button class="btn btn-run" onclick="runGlyph()">üöÄ Run Code</button>
                    <button class="btn btn-clear" onclick="clearOutput()">üóëÔ∏è Clear</button>
                </div>
            </div>
            
            <div class="output-section">
                <div class="section-title">üìä Output & Results</div>
                <div class="output-display" id="output">
<span class="info">üîÆ Glyph Language - MULTI-INPUT FIXED!</span>
<span class="info">Try: [‚óã 5] ‚Üí [‚ñ∑ multiply] ‚Üê [‚óã 6] ‚Üí [‚ñ∑ print]</span>
<span class="info">Should output: 30 (not 5 or 6)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WORKING Glyph Engine with PROPER Multi-Input Support
        class WorkingGlyphEngine {
            constructor() {
                this.builtins = {
                    'print': (value) => {
                        this.output(`üì§ OUTPUT: ${value}`);
                        return value;
                    },
                    'multiply': (inputs) => {
                        const result = inputs.reduce((a, b) => a * b, 1);
                        this.output(`üî¢ MULTIPLY: ${inputs.join(' √ó ')} = ${result}`);
                        return result;
                    },
                    'add': (inputs) => {
                        const result = inputs.reduce((a, b) => a + b, 0);
                        this.output(`‚ûï ADD: ${inputs.join(' + ')} = ${result}`);
                        return result;
                    },
                    'concat': (inputs) => {
                        const result = inputs.join('');
                        this.output(`üîó CONCAT: "${inputs.join('" + "')}" = "${result}"`);
                        return result;
                    },
                    'to_upper': (inputs) => {
                        const result = String(inputs[0]).toUpperCase();
                        this.output(`üî† TO_UPPER: "${inputs[0]}" ‚Üí "${result}"`);
                        return result;
                    },
                    'to_lower': (inputs) => {
                        const result = String(inputs[0]).toLowerCase();
                        this.output(`üî° TO_LOWER: "${inputs[0]}" ‚Üí "${result}"`);
                        return result;
                    }
                };
                this.outputElement = document.getElementById('output');
            }

            output(message) {
                const line = document.createElement('div');
                line.textContent = message;
                this.outputElement.appendChild(line);
                this.outputElement.scrollTop = this.outputElement.scrollHeight;
            }

            clearOutput() {
                this.outputElement.innerHTML = '';
            }

            // FIXED: PROPER multi-input parser
            parseAndExecute(code) {
                const lines = code.split('\n').filter(line => line.trim());
                
                for (const line of lines) {
                    this.output(`\nüîç Parsing: ${line}`);
                    this.executeLine(line);
                }
            }

            executeLine(line) {
                try {
                    // Find all function nodes and their inputs
                    const functionMatches = [...line.matchAll(/\[‚ñ∑\s+(\w+)\]/g)];
                    
                    for (const match of functionMatches) {
                        const funcName = match[1];
                        const funcPos = match.index;
                        
                        // Find ALL inputs connected to this function
                        const inputs = this.findInputsForFunction(line, funcPos);
                        
                        this.output(`üéØ Executing ${funcName} with inputs: [${inputs.join(', ')}]`);
                        
                        if (this.builtins[funcName]) {
                            const result = this.builtins[funcName](inputs);
                            this.output(`‚úÖ ${funcName} result: ${result}`);
                            
                            // Pass result to next node if needed
                            this.passToNextNode(line, funcPos, result);
                        } else {
                            this.output(`‚ùå Unknown function: ${funcName}`);
                        }
                    }
                    
                    // Handle simple data flows without functions
                    this.handleSimpleFlow(line);
                    
                } catch (error) {
                    this.output(`üí• Error: ${error.message}`);
                }
            }

            findInputsForFunction(line, funcPos) {
                const inputs = [];
                
                // Look for left arrows pointing TO this function: [data] ‚Üê [function]
                const leftArrowsBefore = this.findLeftArrowsBefore(line, funcPos);
                for (const arrowPos of leftArrowsBefore) {
                    const input = this.findDataBeforeArrow(line, arrowPos);
                    if (input !== null) inputs.push(input);
                }
                
                // Look for right arrows pointing FROM data TO this function: [data] ‚Üí [function]  
                const rightArrowsBefore = this.findRightArrowsBefore(line, funcPos);
                for (const arrowPos of rightArrowsBefore) {
                    const input = this.findDataBeforeArrow(line, arrowPos);
                    if (input !== null) inputs.push(input);
                }
                
                return inputs;
            }

            findLeftArrowsBefore(line, position) {
                const arrows = [];
                let searchPos = 0;
                while (searchPos < position) {
                    const arrowPos = line.indexOf('‚Üê', searchPos);
                    if (arrowPos === -1 || arrowPos >= position) break;
                    arrows.push(arrowPos);
                    searchPos = arrowPos + 1;
                }
                return arrows;
            }

            findRightArrowsBefore(line, position) {
                const arrows = [];
                let searchPos = 0;
                while (searchPos < position) {
                    const arrowPos = line.indexOf('‚Üí', searchPos);
                    if (arrowPos === -1 || arrowPos >= position) break;
                    arrows.push(arrowPos);
                    searchPos = arrowPos + 1;
                }
                return arrows;
            }

            findDataBeforeArrow(line, arrowPos) {
                // Look backward from arrow to find the nearest data node
                let searchPos = arrowPos - 1;
                while (searchPos >= 0) {
                    if (line[searchPos] === ']') {
                        // We found the end of a node, now find its start
                        let nodeStart = line.lastIndexOf('[', searchPos);
                        if (nodeStart !== -1) {
                            const nodeContent = line.substring(nodeStart + 1, searchPos);
                            const match = nodeContent.match(/^([‚óã‚ñ°])\s+(.+)$/);
                            if (match) {
                                return this.parseValue(match[2].trim());
                            }
                        }
                    }
                    searchPos--;
                }
                return null;
            }

            passToNextNode(line, currentPos, value) {
                // Find right arrows after current position
                let arrowPos = line.indexOf('‚Üí', currentPos);
                if (arrowPos !== -1) {
                    // Find what comes after the arrow
                    const afterArrow = line.substring(arrowPos + 1);
                    const nextNodeMatch = afterArrow.match(/\[([‚óã‚ñ°‚ñ∑])\s+([^\]]+)\]/);
                    if (nextNodeMatch) {
                        if (nextNodeMatch[1] === '‚ñ∑') {
                            // Another function - execute it with the value
                            const funcName = nextNodeMatch[2].trim();
                            if (this.builtins[funcName]) {
                                const result = this.builtins[funcName]([value]);
                                this.output(`‚û°Ô∏è Passing to ${funcName}: ${result}`);
                            }
                        } else if (nextNodeMatch[1] === '‚§∂') {
                            // Output node
                            this.output(`üì§ FINAL OUTPUT: ${value}`);
                        }
                    }
                }
            }

            handleSimpleFlow(line) {
                // Handle simple chains like [‚ñ° "hello"] ‚Üí [‚ñ∑ print]
                const simpleFlowMatch = line.match(/\[([‚óã‚ñ°])\s+([^\]]+)\]\s*‚Üí\s*\[‚ñ∑\s+(\w+)\]/);
                if (simpleFlowMatch) {
                    const dataType = simpleFlowMatch[1];
                    const dataValue = this.parseValue(simpleFlowMatch[2].trim());
                    const funcName = simpleFlowMatch[3];
                    
                    if (this.builtins[funcName]) {
                        const result = this.builtins[funcName]([dataValue]);
                        this.output(`üîÑ Simple flow: ${dataValue} ‚Üí ${funcName} = ${result}`);
                    }
                }
            }

            parseValue(value) {
                if (!isNaN(value)) return Number(value);
                if (value === 'true') return true;
                if (value === 'false') return false;
                if ((value.startsWith('"') && value.endsWith('"')) || 
                    (value.startsWith("'") && value.endsWith("'"))) {
                    return value.slice(1, -1);
                }
                return value;
            }
        }

        // Initialize engine
        const glyphEngine = new WorkingGlyphEngine();

        function runGlyph() {
            const code = document.getElementById('codeEditor').value;
            glyphEngine.clearOutput();
            glyphEngine.output('üöÄ Executing Glyph Code...');
            glyphEngine.output('========================================');
            
            try {
                glyphEngine.parseAndExecute(code);
                glyphEngine.output('========================================');
                glyphEngine.output('‚úÖ Execution completed!');
                glyphEngine.output('üéâ Multi-input functions WORKING!');
            } catch (error) {
                glyphEngine.output(`üí• Critical error: ${error.message}`);
            }
        }

        function clearOutput() {
            glyphEngine.clearOutput();
            glyphEngine.output('üóëÔ∏è Output cleared. Ready for execution.');
        }

        // Initial message
        glyphEngine.output('üí° Examples that will work:');
        glyphEngine.output('- [‚óã 5] ‚Üí [‚ñ∑ multiply] ‚Üê [‚óã 6] ‚Üí [‚ñ∑ print]');
        glyphEngine.output('- [‚ñ° "hello"] ‚Üí [‚ñ∑ concat] ‚Üê [‚ñ° " world"] ‚Üí [‚ñ∑ print]');
    </script>
</body>
</html>
